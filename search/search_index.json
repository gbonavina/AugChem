{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Augchem","text":"<p>Welcome to the documentation for Augchem, a Python toolbox for chemical data augmentation, developed in partnership with FAPESP and CINE.</p> <p>Explore the API and usage examples in the sections below.</p>"},{"location":"reference/augchem/","title":"What is Augchem?","text":"<p>Augchem is a toolbox developed in partnership with CINE and FAPESP.</p>"},{"location":"reference/augchem/#why-use-data-augmentation-for-chemical-data","title":"Why use data augmentation for chemical data?","text":"<p>Machine Learning (ML) is gaining prominence in the discovery of new materials, complementing traditional methods by analyzing large volumes of data and identifying patterns. The effectiveness of ML models depends on data quality, making data augmentation techniques essential to improve model accuracy in materials chemistry. However, there is a lack of studies integrating these techniques in this field. This toolbox aims to address this gap in easy-to-use Python libraries for chemical data augmentation.</p>"},{"location":"reference/loader/","title":"Loader","text":"<p>This class is a helper in case you don't have your own QM9 dataset loader. In case you have your own dataset loader, you can ignore this functions.</p> <p>Its important to say that this data augmentation methods aren't exclusive to the QM9 dataset, and can be used to any SMILES, graph or INCHI data.</p>"},{"location":"reference/loader/#augchem.Loader","title":"<code>augchem.Loader(path: Path)</code>","text":"Source code in <code>augchem/core.py</code> <pre><code>def __init__(self, path: Path):\n    self.path = path\n</code></pre>"},{"location":"reference/loader/#augchem.Loader.load_qm9_dataset","title":"<code>load_qm9_dataset(directory_path, list_mols=[])</code>","text":"<p>Load the entire QM9 dataset from a directory containing .xyz files.</p> Source code in <code>augchem/core.py</code> <pre><code>def load_qm9_dataset(self, directory_path, list_mols=[]):\n    \"\"\"Load the entire QM9 dataset from a directory containing .xyz files.\"\"\"\n    X = []\n    Y = []\n    S = []\n    SMILES1 = []\n    SMILES2 = []\n    INCHI1 = []\n    INCHI2 = []\n\n    for file_name in os.listdir(directory_path):\n        if file_name.endswith(\".xyz\"):\n            file_path = os.path.join(directory_path, file_name)\n            molecule_data = self.load_qm9_xyz(file_path)\n            if molecule_data['natoms'] in list_mols or len(list_mols)==0:\n                X.append([molecule_data['atoms'], molecule_data['coordinates']])\n                Y.append(molecule_data['properties'])\n                S.append(molecule_data['natoms'])\n                SMILES1.append(molecule_data['smiles_1'])\n                SMILES2.append(molecule_data['smiles_2'])\n                INCHI1.append(molecule_data['inchi_1'])\n                INCHI2.append(molecule_data['inchi_2'])\n\n    return X, Y, S, SMILES1, SMILES2, INCHI1, INCHI2\n</code></pre>"},{"location":"reference/loader/#augchem.Loader.load_qm9_xyz","title":"<code>load_qm9_xyz(file_path)</code>","text":"<p>Load a single QM9.xyz file.</p> Source code in <code>augchem/core.py</code> <pre><code>def load_qm9_xyz(self, file_path):\n    \"\"\"Load a single QM9.xyz file.\"\"\"\n    with open(file_path, 'r') as f:\n        # Number of atoms\n        natoms = int(f.readline())\n        # Properties are in the second line\n        properties = list(map(float, f.readline().split()[2:]))\n        # Read atomic coordinates and types\n        atoms = []\n        coordinates = []\n        smiles1 = ''\n        smiles2 = '' \n        inchi1 = ''\n        inchi2 = ''\n        # print(properties)\n        for num_line, line in enumerate(f):\n            # print(num_line, line)\n            if num_line &gt;= 0 and num_line &lt; natoms:\n                info = line.replace(\"*^\",\"e\").split()\n                atoms.append(info[0])\n                coordinates.append(list(map(float, info[1:-1])))\n            if num_line == natoms + 1:\n                smiles1, smiles2 = line.split()\n            if num_line == natoms + 2:\n                inchi1, inchi2 = line.split()\n\n    return {\n        \"natoms\": natoms,\n        \"atoms\": atoms,\n        \"coordinates\": np.array(coordinates),\n        \"smiles_1\": smiles1,\n        \"smiles_2\": smiles2,\n        \"inchi_1\": inchi1,\n        \"inchi_2\": inchi2,\n        \"properties\": properties\n    }\n</code></pre>"},{"location":"reference/smiles_methods/","title":"SMILES Methods","text":"<p>This section documents the SMILES strings manipulation and augmentation methods.</p>"},{"location":"reference/smiles_methods/#basic-functions","title":"Basic Functions","text":""},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.atom_positions","title":"<code>augchem.modules.smiles.smiles_modules.atom_positions(smiles: str) -&gt; Tuple[List[str], List[int]]</code>","text":"<p>Extracts individual characters from a SMILES string and identifies indices of atoms.</p> <p>This function tokenizes a SMILES string into individual characters and identifies positions of actual atoms by excluding special characters like brackets,  parentheses, bonds, digits, etc.</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.atom_positions--parameters","title":"Parameters","text":"<p><code>smiles</code> : str     A valid SMILES string representation of a molecule</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.atom_positions--returns","title":"Returns","text":"<p><code>Tuple[List[str]</code>, <code>List[int]]</code>     A tuple containing:     - List of individual characters from the SMILES string     - List of indices where non-special characters (atoms) are located</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.atom_positions--examples","title":"Examples","text":"<p>atom_positions(\"CC(=O)O\") = (['C', 'C', '(', '=', 'O', ')', 'O'], [0, 1, 4, 6])</p> Source code in <code>augchem/modules/smiles/smiles_modules.py</code> <pre><code>def atom_positions(smiles: str) -&gt; Tuple[List[str], List[int]]:\n    \"\"\"\n    Extracts individual characters from a SMILES string and identifies indices of atoms.\n\n    This function tokenizes a SMILES string into individual characters and identifies\n    positions of actual atoms by excluding special characters like brackets, \n    parentheses, bonds, digits, etc.\n\n    Parameters\n    ----------\n    `smiles` : str\n        A valid SMILES string representation of a molecule\n\n    Returns\n    -------\n    `Tuple[List[str]`, `List[int]]`\n        A tuple containing:\n        - List of individual characters from the SMILES string\n        - List of indices where non-special characters (atoms) are located\n\n    Examples\n    --------\n    &gt;&gt;&gt; atom_positions(\"CC(=O)O\") = (['C', 'C', '(', '=', 'O', ')', 'O'], [0, 1, 4, 6])\n    \"\"\"\n    charset = set(['[', ']', '(', ')', '=', '#', '%', '.', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-', '0', '@'])\n\n    tokens = list(smiles)\n    non_charset_indices = []\n\n    for idx, token in enumerate(tokens):\n        if token not in charset:\n            non_charset_indices.append(idx)\n\n    return tokens, non_charset_indices\n</code></pre>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.tokenize","title":"<code>augchem.modules.smiles.smiles_modules.tokenize(smiles: str)</code>","text":"<p>Tokenizes a SMILES string using a regular expression pattern.</p> <p>Splits a SMILES string into chemically meaningful tokens according to a predefined regex pattern. This tokenization preserves atom types, bonds, stereochemistry, and other structural features.</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.tokenize--parameters","title":"Parameters","text":"<p><code>smiles</code> : str     A valid SMILES string representation of a molecule</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.tokenize--returns","title":"Returns","text":"<p><code>List[str]</code>     A list of chemical tokens extracted from the SMILES string</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.tokenize--examples","title":"Examples","text":"<p>tokenize(\"CC(=O)O\") = ['C', 'C', '(', '=', 'O', ')', 'O']</p> <p>tokenize(\"C1=CC=CC=C1\") = ['C', '1', '=', 'C', 'C', '=', 'C', 'C', '=', 'C', '1']</p> Source code in <code>augchem/modules/smiles/smiles_modules.py</code> <pre><code>def tokenize(smiles: str):\n    \"\"\"\n    Tokenizes a SMILES string using a regular expression pattern.\n\n    Splits a SMILES string into chemically meaningful tokens according to a\n    predefined regex pattern. This tokenization preserves atom types, bonds,\n    stereochemistry, and other structural features.\n\n    Parameters\n    ----------\n    `smiles` : str\n        A valid SMILES string representation of a molecule\n\n    Returns\n    -------\n    `List[str]`\n        A list of chemical tokens extracted from the SMILES string\n\n    Examples\n    --------\n    &gt;&gt;&gt; tokenize(\"CC(=O)O\") = ['C', 'C', '(', '=', 'O', ')', 'O']\n\n    &gt;&gt;&gt; tokenize(\"C1=CC=CC=C1\") = ['C', '1', '=', 'C', 'C', '=', 'C', 'C', '=', 'C', '1']\n    \"\"\"\n\n    SMI_REGEX_PATTERN = r\"\"\"(\\[[^\\]]+]|Br?|Cl?|N|O|S|P|F|I|b|c|n|o|s|p|\\(|\\)|\\.|=|#|-|\\+|\\\\|\\/|:|~|@|\\?|&gt;&gt;?|\\*|\\$|\\%[0-9]{2}|[0-9])\"\"\"\n    regex = re.compile(SMI_REGEX_PATTERN)\n\n    tokens = [token for token in regex.findall(smiles)]\n    return tokens\n</code></pre>"},{"location":"reference/smiles_methods/#augmentation-methods","title":"Augmentation Methods","text":""},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.enumerateSmiles","title":"<code>augchem.modules.smiles.smiles_modules.enumerateSmiles(smiles: str) -&gt; Optional[str]</code>","text":"<p>Generates a valid non-canonical SMILES representation of the input molecule.</p> <p>Creates an alternative, but chemically equivalent SMILES string by randomizing the atom ordering while preserving the molecular structure. Returns None if  the generation fails or produces an invalid SMILES.</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.enumerateSmiles--parameters","title":"Parameters","text":"<p><code>smiles</code> : str     A valid SMILES string representation of a molecule</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.enumerateSmiles--returns","title":"Returns","text":"<p><code>Optional[str]</code>     A new, valid SMILES string with randomized atom ordering, or None if generation fails</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.enumerateSmiles--raises","title":"Raises","text":"<p>ValueError     If the input SMILES string is invalid</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.enumerateSmiles--examples","title":"Examples","text":"<p>enumerateSmiles(\"CC(=O)O\") = 'OC(C)=O'</p> Source code in <code>augchem/modules/smiles/smiles_modules.py</code> <pre><code>def enumerateSmiles(smiles: str) -&gt; Optional[str]:\n    \"\"\"\n    Generates a valid non-canonical SMILES representation of the input molecule.\n\n    Creates an alternative, but chemically equivalent SMILES string by randomizing\n    the atom ordering while preserving the molecular structure. Returns None if \n    the generation fails or produces an invalid SMILES.\n\n    Parameters\n    ----------\n    `smiles` : str\n        A valid SMILES string representation of a molecule\n\n    Returns\n    -------\n    `Optional[str]`\n        A new, valid SMILES string with randomized atom ordering, or None if generation fails\n\n    Raises\n    ------\n    ValueError\n        If the input SMILES string is invalid\n\n    Examples\n    --------\n    &gt;&gt;&gt; enumerateSmiles(\"CC(=O)O\") = 'OC(C)=O'\n    \"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        raise ValueError(f\"Invalid SMILES string: {smiles}\")\n\n    random_smiles = Chem.MolToSmiles(mol, canonical=False, doRandom=True)\n    random_mol = Chem.MolFromSmiles(random_smiles)\n    if random_mol is None:\n        return None\n\n    # comparar inhchi a partir de objetos Mol, n\u00e3o de str\n    if Chem.MolToInchi(mol) == Chem.MolToInchi(random_mol):\n        return random_smiles\n\n    return None\n</code></pre>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.mask","title":"<code>augchem.modules.smiles.smiles_modules.mask(smiles: str, mask_ratio: float = 0.5, seed=45) -&gt; List[str]</code>","text":"<p>Replaces random tokens in a SMILES string with a masking token '[M]'.</p> <p>Tokenizes the SMILES string and randomly replaces a specified fraction of tokens with a mask token. Useful for creating partially obscured molecular representations for machine learning applications.</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.mask--parameters","title":"Parameters","text":"<p><code>smiles</code> : str     A valid SMILES string representation of a molecule</p> <p><code>mask_ratio</code> : float, default=0.5     Fraction of tokens to replace with mask tokens (0.0 to 1.0)</p> <p><code>seed</code> : int or numpy.random.RandomState, default=45     Random seed or random number generator for reproducibility</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.mask--returns","title":"Returns","text":"<p><code>str</code>     SMILES string with selected tokens replaced by '[M]'</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.mask--examples","title":"Examples","text":"<p>mask(\"CC(=O)O\", mask_ratio=0.4, seed=42) = 'CM[M]'</p> Source code in <code>augchem/modules/smiles/smiles_modules.py</code> <pre><code>def mask(smiles: str, mask_ratio: float = 0.5, seed = 45) -&gt; List[str]:\n    \"\"\"\n    Replaces random tokens in a SMILES string with a masking token '[M]'.\n\n    Tokenizes the SMILES string and randomly replaces a specified fraction of tokens\n    with a mask token. Useful for creating partially obscured molecular representations\n    for machine learning applications.\n\n    Parameters\n    ----------\n    `smiles` : str\n        A valid SMILES string representation of a molecule\n\n    `mask_ratio` : float, default=0.5\n        Fraction of tokens to replace with mask tokens (0.0 to 1.0)\n\n    `seed` : int or numpy.random.RandomState, default=45\n        Random seed or random number generator for reproducibility\n\n    Returns\n    -------\n    `str`\n        SMILES string with selected tokens replaced by '[M]'\n\n    Examples\n    --------\n    &gt;&gt;&gt; mask(\"CC(=O)O\", mask_ratio=0.4, seed=42) = 'C[M](=O)[M]'\n    \"\"\"\n    token = '[M]'\n\n    if isinstance(seed, int):\n        rng = np.random.RandomState(seed)\n    else:\n        rng = seed\n\n    sliced_smiles = tokenize(smiles)\n\n    masked = sliced_smiles.copy()\n\n    mask_indices = rng.choice(len(masked), int(len(masked) * mask_ratio), replace=False)\n\n    for idx in mask_indices:\n        masked[idx] = token\n\n    masked_string = ''.join(masked)\n\n    return masked_string\n</code></pre>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.delete","title":"<code>augchem.modules.smiles.smiles_modules.delete(smiles: str, delete_ratio: float = 0.3, seed=45) -&gt; List[str]</code>","text":"<p>Removes random tokens from a SMILES string.</p> <p>Tokenizes the SMILES string and randomly deletes a specified fraction of tokens. This creates an incomplete representation that can be used for data augmentation or model robustness testing.</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.delete--parameters","title":"Parameters","text":"<p><code>smiles</code> : str     A valid SMILES string representation of a molecule</p> <p><code>delete_ratio</code> : float, default=0.3     Fraction of tokens to delete (0.0 to 1.0)</p> <p><code>seed</code> : int or numpy.random.RandomState, default=45     Random seed or random number generator for reproducibility</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.delete--returns","title":"Returns","text":"<p><code>str</code>     SMILES string with selected tokens removed</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.delete--examples","title":"Examples","text":"<p>delete(\"CC(=O)O\", delete_ratio=0.3, seed=42) = 'C(=O)O'</p> Source code in <code>augchem/modules/smiles/smiles_modules.py</code> <pre><code>def delete(smiles: str, delete_ratio: float = 0.3, seed = 45) -&gt; List[str]:\n    \"\"\"\n    Removes random tokens from a SMILES string.\n\n    Tokenizes the SMILES string and randomly deletes a specified fraction of tokens.\n    This creates an incomplete representation that can be used for data augmentation\n    or model robustness testing.\n\n    Parameters\n    ----------\n    `smiles` : str\n        A valid SMILES string representation of a molecule\n\n    `delete_ratio` : float, default=0.3\n        Fraction of tokens to delete (0.0 to 1.0)\n\n    `seed` : int or numpy.random.RandomState, default=45\n        Random seed or random number generator for reproducibility\n\n    Returns\n    -------\n    `str`\n        SMILES string with selected tokens removed\n\n    Examples\n    --------\n    &gt;&gt;&gt; delete(\"CC(=O)O\", delete_ratio=0.3, seed=42) = 'C(=O)O'\n    \"\"\"\n\n    if isinstance(seed, int):\n        rng = np.random.RandomState(seed)\n    else:\n        rng = seed\n\n    sliced_smiles = tokenize(smiles)\n\n    deleted = sliced_smiles.copy()\n\n    delete_indices = rng.choice(len(deleted), int(len(deleted) * delete_ratio), replace=False)\n\n    for idx in delete_indices:\n        deleted[idx] = ''\n\n    deleted_string = ''.join(deleted)    \n\n    return deleted_string\n</code></pre>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.swap","title":"<code>augchem.modules.smiles.smiles_modules.swap(smiles: str, seed=45) -&gt; List[str]</code>","text":"<p>Exchanges two random atom tokens within a SMILES string.</p> <p>Identifies non-special character positions in the SMILES string and swaps two randomly selected atoms. This preserves the token count but alters the molecular structure.</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.swap--parameters","title":"Parameters","text":"<p><code>smiles</code> : str     A valid SMILES string representation of a molecule <code>seed</code> : int or numpy.random.RandomState, default=45     Random seed or random number generator for reproducibility</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.swap--returns","title":"Returns","text":"<p>str     SMILES string with two atoms swapped</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.swap--examples","title":"Examples","text":"<p>swap(\"CC(=O)O\", seed=42) = 'OC(=O)C'</p> Source code in <code>augchem/modules/smiles/smiles_modules.py</code> <pre><code>def swap(smiles: str, seed = 45) -&gt; List[str]:\n    \"\"\"\n    Exchanges two random atom tokens within a SMILES string.\n\n    Identifies non-special character positions in the SMILES string and swaps\n    two randomly selected atoms. This preserves the token count but alters\n    the molecular structure.\n\n    Parameters\n    ----------\n    `smiles` : str\n        A valid SMILES string representation of a molecule\n    `seed` : int or numpy.random.RandomState, default=45\n        Random seed or random number generator for reproducibility\n\n    Returns\n    -------\n    str\n        SMILES string with two atoms swapped\n\n    Examples\n    --------\n    &gt;&gt;&gt; swap(\"CC(=O)O\", seed=42) = 'OC(=O)C'\n    \"\"\"\n\n    if isinstance(seed, int):\n        rng = np.random.RandomState(seed)\n    else:\n        rng = seed\n\n    tokens, non_charset_indices = atom_positions(smiles)\n    swapped = tokens.copy()\n\n    idx1, idx2 = rng.choice(non_charset_indices, 2, replace=False)\n    swapped[idx1], swapped[idx2] = swapped[idx2], swapped[idx1]\n\n    swapped_string = ''.join(swapped)\n\n    return swapped_string\n</code></pre>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.fusion","title":"<code>augchem.modules.smiles.smiles_modules.fusion(smiles: str, mask_ratio: float = 0.05, delete_ratio: float = 0.3, seed=45) -&gt; List[str]</code>","text":"<p>Applies one randomly selected augmentation method to a SMILES string.</p> <p>Randomly chooses between masking, deletion, or swapping transformations and applies it to the input SMILES. This provides a diverse set of augmentation possibilities with a single function call.</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.fusion--parameters","title":"Parameters","text":"<p><code>smiles</code> : str     A valid SMILES string representation of a molecule</p> <p><code>mask_ratio</code> : float, default=0.05     Fraction of tokens to mask if masking is selected (0.0 to 1.0)</p> <p><code>delete_ratio</code> : float, default=0.3     Fraction of tokens to delete if deletion is selected (0.0 to 1.0)</p> <p><code>seed</code> : int or numpy.random.RandomState, default=45     Random seed or random number generator for reproducibility</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.fusion--returns","title":"Returns","text":"<p><code>str</code>     Augmented SMILES string</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.fusion--raises","title":"Raises","text":"<p>ValueError     If input SMILES is empty or if augmentation fails</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.fusion--examples","title":"Examples","text":"<p>fusion(\"CC(=O)O\", seed=42) = 'CC(O)='</p> Source code in <code>augchem/modules/smiles/smiles_modules.py</code> <pre><code>def fusion(smiles: str, mask_ratio: float = 0.05, delete_ratio: float = 0.3, seed = 45) -&gt; List[str]:\n    \"\"\"\n    Applies one randomly selected augmentation method to a SMILES string.\n\n    Randomly chooses between masking, deletion, or swapping transformations and\n    applies it to the input SMILES. This provides a diverse set of augmentation\n    possibilities with a single function call.\n\n    Parameters\n    ----------\n    `smiles` : str\n        A valid SMILES string representation of a molecule\n\n    `mask_ratio` : float, default=0.05\n        Fraction of tokens to mask if masking is selected (0.0 to 1.0)\n\n    `delete_ratio` : float, default=0.3\n        Fraction of tokens to delete if deletion is selected (0.0 to 1.0)\n\n    `seed` : int or numpy.random.RandomState, default=45\n        Random seed or random number generator for reproducibility\n\n    Returns\n    -------\n    `str`\n        Augmented SMILES string\n\n    Raises\n    ------\n    ValueError\n        If input SMILES is empty or if augmentation fails\n\n    Examples\n    --------\n    &gt;&gt;&gt; fusion(\"CC(=O)O\", seed=42) = 'CC(O)='\n    \"\"\"\n\n    if hasattr(seed, 'choice') and callable(seed.choice):\n        rng = seed\n    else:\n        rng = np.random.RandomState(seed)\n\n    if not smiles:\n        raise ValueError(\"Empty SMILES string isn't valid.\")\n\n    chosen = rng.choice(3, 1)[0]\n\n    try:\n        if chosen == 0:\n            augmented = mask(smiles, mask_ratio=mask_ratio, seed=rng)\n        elif chosen == 1:\n            augmented = delete(smiles, delete_ratio=delete_ratio, seed=rng)\n        else:\n            augmented = swap(smiles, seed=rng)\n\n    except Exception as e:\n        print(f\"Error during augmentation of {smiles}: {str(e)}\")\n        raise ValueError(e) \n\n    return augmented\n</code></pre>"},{"location":"reference/smiles_methods/#dataset-augmentation","title":"Dataset Augmentation","text":""},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.augment_dataset","title":"<code>augchem.modules.smiles.smiles_modules.augment_dataset(col_to_augment: str, dataset: pd.DataFrame, augmentation_methods: List[str], mask_ratio: float = 0.1, property_col: str = None, delete_ratio: float = 0.3, augment_percentage: float = 0.2, seed: int = 42)</code>","text":"<p>Applies selected augmentation methods to SMILES strings in a dataset.</p> <p>Generates augmented variants of molecular SMILES strings using specified methods and adds them to the dataset. Tracks relationships between original and augmented molecules using parent indices.</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.augment_dataset--parameters","title":"Parameters","text":"<p><code>col_to_augment</code> : str     Column name containing SMILES strings to augment</p> <p><code>dataset</code> : pd.DataFrame     DataFrame containing molecular data with SMILES strings</p> <p><code>augmentation_methods</code> : List[str]     List of methods to apply. Valid options: \"mask\", \"delete\", \"swap\", \"fusion\", \"enumeration\"</p> <p><code>mask_ratio</code> : float, default=0.1     Fraction of tokens to mask when using mask augmentation</p> <p><code>property_col</code> : str, optional     Column name containing property values to preserve in augmented data</p> <p><code>delete_ratio</code> : float, default=0.3     Fraction of tokens to delete when using delete augmentation</p> <p><code>augment_percentage</code> : float, default=0.2     Target size of augmented dataset as a fraction of original dataset size</p> <p><code>seed</code> : int, default=42     Random seed for reproducibility</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.augment_dataset--returns","title":"Returns","text":"<p><code>pd.DataFrame</code>     Original dataset with augmented molecules appended, including a 'parent_idx'     column that references original molecule indices</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.augment_dataset--raises","title":"Raises","text":"<p>ValueError     If input data is not in SMILES format or an unknown augmentation method is specified</p>"},{"location":"reference/smiles_methods/#augchem.modules.smiles.smiles_modules.augment_dataset--notes","title":"Notes","text":"<p>Property columns with names starting with \"Property_\" will be set to \"-\" in augmented rows.</p> Source code in <code>augchem/modules/smiles/smiles_modules.py</code> <pre><code>def augment_dataset(col_to_augment: str, dataset: pd.DataFrame, augmentation_methods: List[str], mask_ratio: float = 0.1, property_col: str = None, delete_ratio: float = 0.3,\n                     augment_percentage: float = 0.2, seed: int = 42):\n    \"\"\"\n    Applies selected augmentation methods to SMILES strings in a dataset.\n\n    Generates augmented variants of molecular SMILES strings using specified methods\n    and adds them to the dataset. Tracks relationships between original and augmented\n    molecules using parent indices.\n\n    Parameters\n    ----------\n    `col_to_augment` : str\n        Column name containing SMILES strings to augment\n\n    `dataset` : pd.DataFrame\n        DataFrame containing molecular data with SMILES strings\n\n    `augmentation_methods` : List[str]\n        List of methods to apply. Valid options: \"mask\", \"delete\", \"swap\", \"fusion\", \"enumeration\"\n\n    `mask_ratio` : float, default=0.1\n        Fraction of tokens to mask when using mask augmentation\n\n    `property_col` : str, optional\n        Column name containing property values to preserve in augmented data\n\n    `delete_ratio` : float, default=0.3\n        Fraction of tokens to delete when using delete augmentation\n\n    `augment_percentage` : float, default=0.2\n        Target size of augmented dataset as a fraction of original dataset size\n\n    `seed` : int, default=42\n        Random seed for reproducibility\n\n    Returns\n    -------\n    `pd.DataFrame`\n        Original dataset with augmented molecules appended, including a 'parent_idx'\n        column that references original molecule indices\n\n    Raises\n    ------\n    ValueError\n        If input data is not in SMILES format or an unknown augmentation method is specified\n\n    Notes\n    -----\n    Property columns with names starting with \"Property_\" will be set to \"-\" in augmented rows.\n    \"\"\"\n\n    try:\n        mol = Chem.MolFromSmiles(dataset[col_to_augment][0])\n    except Exception as e:\n        raise ValueError(\"Input appears to be in the wrong format. This function only works with SMILES format.\")\n\n    rng = np.random.RandomState(seed)\n\n    if property_col:\n        working_copy = dataset[[col_to_augment, property_col]].copy()\n    else:\n        working_copy = dataset[[col_to_augment]].copy()\n\n    target_new_rows = int(len(dataset) * augment_percentage)\n\n    new_rows = []\n    augmented_count = 0\n\n    while augmented_count &lt; target_new_rows:\n        try:\n            augmented_smiles: List[str] = []\n            for method in augmentation_methods:\n                if method == \"mask\":\n                    row_to_augment = rng.randint(low=0, high=(len(dataset)-1))\n                    original_idx = working_copy.index[row_to_augment]\n                    row = working_copy.iloc[row_to_augment].copy()\n\n                    smiles = row[col_to_augment]\n                    # print(f\"Augmenting {smiles} with {method} method.\")\n\n                    augmented_smiles.append(mask(\n                        smiles,\n                        mask_ratio=mask_ratio,\n                        seed=rng\n                    ))\n                elif method == \"delete\":\n                    row_to_augment = rng.randint(low=0, high=(len(dataset)-1))\n                    original_idx = working_copy.index[row_to_augment]\n                    row = working_copy.iloc[row_to_augment].copy()\n\n                    smiles = row[col_to_augment]\n                    # print(f\"Augmenting {smiles} with {method} method.\")\n\n                    augmented_smiles.append(delete(\n                        smiles,\n                        delete_ratio=delete_ratio,\n                        seed=rng\n                    ))\n                elif method == \"swap\":\n                    row_to_augment = rng.randint(low=0, high=(len(dataset)-1))\n                    original_idx = working_copy.index[row_to_augment]\n                    row = working_copy.iloc[row_to_augment].copy()\n\n                    smiles = row[col_to_augment]\n                    # print(f\"Augmenting {smiles} with {method} method.\")\n\n                    augmented_smiles.append(swap(\n                        smiles,\n                        seed=rng\n                    ))\n                elif method == \"fusion\":\n                    row_to_augment = rng.randint(low=0, high=(len(dataset)-1))\n                    original_idx = working_copy.index[row_to_augment]\n                    row = working_copy.iloc[row_to_augment].copy()\n\n                    smiles = row[col_to_augment]\n                    # print(f\"Augmenting {smiles} with {method} method.\")\n\n                    augmented_smiles.append(fusion(\n                        smiles,\n                        mask_ratio=mask_ratio,\n                        delete_ratio=delete_ratio,\n                        seed=rng\n                    ))\n                elif method == \"enumeration\":\n                    row_to_augment = rng.randint(low=0, high=(len(dataset)-1))\n                    original_idx = working_copy.index[row_to_augment]\n                    row = working_copy.iloc[row_to_augment].copy()\n\n                    smiles = row[col_to_augment]\n                    # print(f\"Augmenting {smiles} with {method} method.\")\n\n                    augmented_smiles.append(enumerateSmiles(\n                        smiles\n                    ))\n                else:\n                    raise ValueError(f\"Unknown augmentation method: {method}\")\n\n            augmented_smiles = list(dict.fromkeys(augmented_smiles))\n            augmented_smiles = augmented_smiles[: target_new_rows - augmented_count]\n\n            for aug_smiles in augmented_smiles:\n                new_row = row.copy()\n                new_row[col_to_augment] = aug_smiles\n\n                for prop_col in [c for c in new_row.index if c.startswith(\"Property_\")]:\n                    new_row[prop_col] = \"-\"\n                new_row[\"parent_idx\"] = original_idx\n                new_rows.append(new_row)\n                augmented_count += 1\n                if augmented_count &gt;= target_new_rows:\n                    break\n\n            if augmented_count &gt;= target_new_rows:\n                break\n\n        except Exception:\n            continue\n\n    filtered_df = dataset[[col_to_augment, property_col]].copy()\n\n    if new_rows:\n        new_data = pd.DataFrame(new_rows)\n        augmented_df = pd.concat([filtered_df, new_data], ignore_index=True)\n        augmented_df = augmented_df.fillna(\"-1\")\n\n    return augmented_df\n</code></pre>"},{"location":"reference/smiles_module/","title":"SMILES Module","text":"<p>This module provides methods for augmenting molecular data in SMILES format.</p>"},{"location":"reference/smiles_module/#augchem.Augmentator.SMILESModule","title":"<code>augchem.Augmentator.SMILESModule(parent)</code>","text":"<p>Module for augmenting molecular data in SMILES format.</p> <p>Provides methods for generating augmented SMILES representations using various techniques including masking, deletion, swapping, fusion, and enumeration.</p> Source code in <code>augchem/core.py</code> <pre><code>def __init__(self, parent):\n    self.parent = parent\n</code></pre>"},{"location":"reference/smiles_module/#augchem.Augmentator.SMILESModule.augment_data","title":"<code>augment_data(dataset: Path, mask_ratio: float = 0.1, delete_ratio: float = 0.3, seed: int = 42, augment_percentage: float = 0.2, augmentation_methods: List[str] = ['fusion', 'enumerate'], col_to_augment: str = 'SMILES', property_col: str = None) -&gt; pd.DataFrame</code>","text":"<p>Augment molecular SMILES data from a CSV file.</p> <p>Reads SMILES strings from a CSV file, applies specified augmentation methods, and returns the augmented dataset. Also saves the augmented dataset to a new CSV file.</p>"},{"location":"reference/smiles_module/#augchem.Augmentator.SMILESModule.augment_data--parameters","title":"Parameters","text":"<p><code>dataset</code> : Path     Path to the CSV file containing SMILES data to augment</p> <p><code>mask_ratio</code> : float, default=0.1     Fraction of tokens to mask when using masking-based augmentation methods</p> <p><code>delete_ratio</code> : float, default=0.3     Fraction of tokens to delete when using deletion-based augmentation methods</p> <p><code>seed</code> : int, default=42     Random seed for reproducible augmentation</p> <p><code>augment_percentage</code> : float, default=0.2     Target size of augmented dataset as a fraction of original dataset size</p> <p><code>augmentation_methods</code> : List[str], default=[\"fusion\", \"enumerate\"]     List of augmentation methods to apply. Valid options include:      \"mask\", \"delete\", \"swap\", \"fusion\", \"enumeration\"</p> <p><code>col_to_augment</code> : str, default='SMILES'     Column name in the CSV file containing SMILES strings to augment</p> <p><code>property_col</code> : str, optional     Column name containing property values to preserve in augmented data</p>"},{"location":"reference/smiles_module/#augchem.Augmentator.SMILESModule.augment_data--returns","title":"Returns","text":"<p><code>pd.DataFrame</code>     DataFrame containing both original and augmented molecules, with a 'parent_idx'     column linking augmented molecules to their source molecules</p>"},{"location":"reference/smiles_module/#augchem.Augmentator.SMILESModule.augment_data--notes","title":"Notes","text":"<p>The augmented dataset is automatically saved to \"Augmented_QM9.csv\" in the current working directory.</p> Source code in <code>augchem/core.py</code> <pre><code>def augment_data(self, dataset: Path, mask_ratio: float = 0.1, delete_ratio: float = 0.3, seed: int = 42, \n                    augment_percentage: float = 0.2, augmentation_methods: List[str] = [\"fusion\", \"enumerate\"], col_to_augment: str = 'SMILES',\n                    property_col: str = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Augment molecular SMILES data from a CSV file.\n\n    Reads SMILES strings from a CSV file, applies specified augmentation methods,\n    and returns the augmented dataset. Also saves the augmented dataset to a new CSV file.\n\n    Parameters\n    ----------\n    `dataset` : Path\n        Path to the CSV file containing SMILES data to augment\n\n    `mask_ratio` : float, default=0.1\n        Fraction of tokens to mask when using masking-based augmentation methods\n\n    `delete_ratio` : float, default=0.3\n        Fraction of tokens to delete when using deletion-based augmentation methods\n\n    `seed` : int, default=42\n        Random seed for reproducible augmentation\n\n    `augment_percentage` : float, default=0.2\n        Target size of augmented dataset as a fraction of original dataset size\n\n    `augmentation_methods` : List[str], default=[\"fusion\", \"enumerate\"]\n        List of augmentation methods to apply. Valid options include: \n        \"mask\", \"delete\", \"swap\", \"fusion\", \"enumeration\"\n\n    `col_to_augment` : str, default='SMILES'\n        Column name in the CSV file containing SMILES strings to augment\n\n    `property_col` : str, optional\n        Column name containing property values to preserve in augmented data\n\n    Returns\n    -------\n    `pd.DataFrame`\n        DataFrame containing both original and augmented molecules, with a 'parent_idx'\n        column linking augmented molecules to their source molecules\n\n    Notes\n    -----\n    The augmented dataset is automatically saved to \"Augmented_QM9.csv\" in the\n    current working directory.\n    \"\"\"\n    df = pd.read_csv(dataset)\n    new_df = augment_dataset(dataset=df, augmentation_methods=augmentation_methods, mask_ratio=mask_ratio, delete_ratio=delete_ratio, \n                               col_to_augment=col_to_augment, augment_percentage=augment_percentage, seed=seed,\n                               property_col=property_col)\n\n\n    new_df = new_df.drop_duplicates()\n    new_df.to_csv(f\"Augmented_{dataset}\", index=True, float_format='%.8e')\n\n    new_data = len(new_df) - len(df)\n    print(f\"Generated new {new_data} SMILES\")\n\n    return new_df\n</code></pre>"}]}